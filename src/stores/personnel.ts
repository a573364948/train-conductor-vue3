import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { EnhancedConductor, PersonnelChange, ApplicationSettings } from '@/types'
import { useMainStore } from './index'

export const usePersonnelStore = defineStore('personnel', () => {
  // çŠ¶æ€
  const enhancedConductors = ref<Record<string, EnhancedConductor>>({})
  const personnelChanges = ref<PersonnelChange[]>([])
  const applicationSettings = ref<ApplicationSettings>({
    tempPeriod: 3,
    autoExpiry: false,
    approvalRequired: false
  })
  const loading = ref(false)
  const error = ref<string | null>(null)

  // è·å–ä¸»Storeå®ä¾‹
  const mainStore = useMainStore()

  // è®¡ç®—å±æ€§
  const allConductors = computed(() => Object.values(enhancedConductors.value))

  const getConductorsByStatus = computed(() => {
    return (status: string) => 
      allConductors.value.filter(c => c.status === status)
  })

  const getConductorsByDepartment = computed(() => {
    return (department: string) =>
      allConductors.value.filter(c => c.department === department)
  })

  const statusStatistics = computed(() => {
    const conductors = allConductors.value
    return {
      æ­£å¼å¯ç”¨: conductors.filter(c => c.status === 'æ­£å¼å¯ç”¨').length,
      ä¸´æ—¶å¯ç”¨: conductors.filter(c => c.status === 'ä¸´æ—¶å¯ç”¨').length,
      åå¤‡: conductors.filter(c => c.status === 'åå¤‡').length,
      å…èŒ: conductors.filter(c => c.status === 'å…èŒ').length,
      total: conductors.length
    }
  })

  const departmentStatistics = computed(() => {
    const stats: Record<string, any> = {}
    allConductors.value.forEach(conductor => {
      if (!stats[conductor.department]) {
        stats[conductor.department] = {
          department: conductor.department,
          æ­£å¼å¯ç”¨: 0,
          ä¸´æ—¶å¯ç”¨: 0,
          åå¤‡: 0,
          å…èŒ: 0,
          total: 0
        }
      }
      stats[conductor.department][conductor.status]++
      stats[conductor.department].total++
    })
    return Object.values(stats)
  })

  // æ“ä½œæ–¹æ³•
  const addConductor = async (conductorData: Partial<EnhancedConductor>) => {
    try {
      loading.value = true
      error.value = null

      const id = generateId()
      const newConductor: EnhancedConductor = {
        id,
        name: conductorData.name || '',
        department: conductorData.department || '',
        employeeId: conductorData.employeeId || '',
        status: conductorData.status || 'åå¤‡',
        note: conductorData.note || '',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        ...conductorData
      }

      enhancedConductors.value[id] = newConductor

      // è®°å½•å¼‚åŠ¨
      await addPersonnelChange({
        employeeId: newConductor.employeeId,
        employeeName: newConductor.name,
        changeType: 'å…¥èŒ',
        toStatus: newConductor.status,
        toDepartment: newConductor.department,
        changeDate: new Date().toISOString().split('T')[0],
        operator: 'ç³»ç»Ÿ',
        reason: 'æ–°å¢äººå‘˜',
        isAutoGenerated: false
      })

      await saveToDatabase()
      return newConductor
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'æ·»åŠ äººå‘˜å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }

  const updateConductor = async (id: string, updates: Partial<EnhancedConductor>) => {
    try {
      loading.value = true
      error.value = null

      const current = enhancedConductors.value[id]
      if (!current) {
        throw new Error('äººå‘˜ä¸å­˜åœ¨')
      }

      const oldStatus = current.status
      const oldDepartment = current.department

      const updated = {
        ...current,
        ...updates,
        updatedAt: Date.now()
      }

      enhancedConductors.value[id] = updated

      // è®°å½•çŠ¶æ€å˜æ›´å¼‚åŠ¨
      if (updates.status && updates.status !== oldStatus) {
        await addPersonnelChange({
          employeeId: current.employeeId,
          employeeName: current.name,
          changeType: 'çŠ¶æ€å˜æ›´',
          fromStatus: oldStatus,
          toStatus: updates.status,
          changeDate: new Date().toISOString().split('T')[0],
          operator: 'ç³»ç»Ÿ',
          reason: 'çŠ¶æ€æ›´æ–°',
          isAutoGenerated: false
        })
      }

      // è®°å½•éƒ¨é—¨è°ƒåŠ¨å¼‚åŠ¨
      if (updates.department && updates.department !== oldDepartment) {
        await addPersonnelChange({
          employeeId: current.employeeId,
          employeeName: current.name,
          changeType: 'éƒ¨é—¨è°ƒåŠ¨',
          fromDepartment: oldDepartment,
          toDepartment: updates.department,
          changeDate: new Date().toISOString().split('T')[0],
          operator: 'ç³»ç»Ÿ',
          reason: 'éƒ¨é—¨è°ƒæ•´',
          isAutoGenerated: false
        })
      }

      await saveToDatabase()
      return updated
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'æ›´æ–°äººå‘˜å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }

  const deleteConductor = async (id: string) => {
    try {
      loading.value = true
      error.value = null

      const conductor = enhancedConductors.value[id]
      if (!conductor) {
        throw new Error('äººå‘˜ä¸å­˜åœ¨')
      }

      // è®°å½•ç¦»èŒå¼‚åŠ¨
      await addPersonnelChange({
        employeeId: conductor.employeeId,
        employeeName: conductor.name,
        changeType: 'ç¦»èŒ',
        fromStatus: conductor.status,
        fromDepartment: conductor.department,
        changeDate: new Date().toISOString().split('T')[0],
        operator: 'ç³»ç»Ÿ',
        reason: 'äººå‘˜åˆ é™¤',
        isAutoGenerated: false
      })

      delete enhancedConductors.value[id]
      await saveToDatabase()
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'åˆ é™¤äººå‘˜å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }

  const addPersonnelChange = async (changeData: Omit<PersonnelChange, 'id' | 'createdAt' | 'updatedAt'>) => {
    const change: PersonnelChange = {
      id: generateId(),
      createdAt: Date.now(),
      updatedAt: Date.now(),
      ...changeData
    }
    
    personnelChanges.value.unshift(change) // æ–°è®°å½•æ”¾åœ¨æœ€å‰é¢
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    await saveToDatabase()
    
    return change
  }

  const createApplicationRelatedChange = async (
    application: any,
    conductor: EnhancedConductor,
    oldStatus: string
  ) => {
    let changeType: PersonnelChange['changeType'] = 'çŠ¶æ€å˜æ›´'
    let reason = `ç”³è¯·å®¡æ‰¹ï¼š${application.type}ç”³è¯·å·²é€šè¿‡`
    
    // éƒ¨é—¨å˜æ›´æ£€æŸ¥
    const departmentChanged = application.targetDepartment !== application.currentDepartment
    if (departmentChanged) {
      changeType = 'éƒ¨é—¨è°ƒåŠ¨'
      reason += `ï¼ŒåŒæ—¶è°ƒåŠ¨è‡³${application.targetDepartment}`
    }

    const changeData: Omit<PersonnelChange, 'id' | 'createdAt' | 'updatedAt'> = {
      employeeId: conductor.employeeId,
      employeeName: conductor.name,
      changeType,
      fromStatus: oldStatus,
      toStatus: conductor.status,
      fromDepartment: departmentChanged ? application.currentDepartment : undefined,
      toDepartment: departmentChanged ? application.targetDepartment : undefined,
      changeDate: application.approvalDate || new Date().toISOString().split('T')[0],
      reason,
      operator: application.approver || 'ç³»ç»Ÿ',
      notes: application.note || undefined,
      relatedApplicationId: application.id,
      isAutoGenerated: true
    }

    return addPersonnelChange(changeData)
  }

  const getPersonnelChanges = (filters?: {
    employeeId?: string
    changeType?: string
    dateRange?: [string, string]
    department?: string
    isAutoGenerated?: boolean
  }) => {
    let filtered = [...personnelChanges.value]

    if (filters?.employeeId) {
      const query = filters.employeeId.toLowerCase()
      filtered = filtered.filter(change => 
        change.employeeId.toLowerCase().includes(query) ||
        change.employeeName.toLowerCase().includes(query)
      )
    }

    if (filters?.changeType) {
      filtered = filtered.filter(change => change.changeType === filters.changeType)
    }

    if (filters?.dateRange) {
      const [startDate, endDate] = filters.dateRange
      filtered = filtered.filter(change => 
        change.changeDate >= startDate && change.changeDate <= endDate
      )
    }

    if (filters?.department) {
      filtered = filtered.filter(change => 
        change.fromDepartment === filters.department ||
        change.toDepartment === filters.department
      )
    }

    if (filters?.isAutoGenerated !== undefined) {
      filtered = filtered.filter(change => change.isAutoGenerated === filters.isAutoGenerated)
    }

    return filtered.sort((a, b) => b.createdAt - a.createdAt)
  }

  const getPersonnelChangeStatistics = () => {
    const stats = {
      total: personnelChanges.value.length,
      byType: {
        'çŠ¶æ€å˜æ›´': 0,
        'éƒ¨é—¨è°ƒåŠ¨': 0,
        'èŒåŠ¡è°ƒæ•´': 0,
        'å…¥èŒ': 0,
        'ç¦»èŒ': 0,
        'å…¶ä»–': 0
      },
      byMonth: {} as Record<string, number>,
      recentChanges: personnelChanges.value.slice(0, 10),
      autoGenerated: personnelChanges.value.filter(c => c.isAutoGenerated).length,
      manual: personnelChanges.value.filter(c => !c.isAutoGenerated).length
    }

    personnelChanges.value.forEach(change => {
      stats.byType[change.changeType]++
      
      const month = change.changeDate.substring(0, 7)
      stats.byMonth[month] = (stats.byMonth[month] || 0) + 1
    })

    return stats
  }

  const deletePersonnelChange = async (changeId: string) => {
    const index = personnelChanges.value.findIndex(change => change.id === changeId)
    if (index === -1) {
      throw new Error('å¼‚åŠ¨è®°å½•ä¸å­˜åœ¨')
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„è®°å½•
    const change = personnelChanges.value[index]
    if (change.isAutoGenerated) {
      throw new Error('è‡ªåŠ¨ç”Ÿæˆçš„å¼‚åŠ¨è®°å½•ä¸èƒ½åˆ é™¤')
    }

    personnelChanges.value.splice(index, 1)
    await saveToDatabase()
  }

  const updatePersonnelChange = async (changeId: string, updateData: Partial<PersonnelChange>) => {
    const index = personnelChanges.value.findIndex(change => change.id === changeId)
    if (index === -1) {
      throw new Error('å¼‚åŠ¨è®°å½•ä¸å­˜åœ¨')
    }

    const change = personnelChanges.value[index]
    if (change.isAutoGenerated) {
      throw new Error('è‡ªåŠ¨ç”Ÿæˆçš„å¼‚åŠ¨è®°å½•ä¸èƒ½ä¿®æ”¹')
    }

    personnelChanges.value[index] = {
      ...change,
      ...updateData,
      updatedAt: Date.now()
    }

    await saveToDatabase()
  }

  const getPersonnelChangesByEmployee = (employeeId: string) => {
    return personnelChanges.value
      .filter(change => change.employeeId === employeeId)
      .sort((a, b) => b.createdAt - a.createdAt)
  }

  const syncWithMainStore = async () => {
    try {
      loading.value = true
      
      // å°†ç°æœ‰çš„åŸºç¡€Conductoræ•°æ®è½¬æ¢ä¸ºEnhancedConductor
      const basicConductors = mainStore.conductors
      
      basicConductors.forEach(conductor => {
        if (!enhancedConductors.value[conductor.id]) {
          enhancedConductors.value[conductor.id] = {
            ...conductor,
            employeeId: conductor.id, // ä½¿ç”¨ç°æœ‰IDä½œä¸ºå·¥å·
            status: 'æ­£å¼å¯ç”¨', // é»˜è®¤çŠ¶æ€
            note: '',
            createdAt: Date.now(),
            updatedAt: Date.now()
          }
        }
      })

      await saveToDatabase()
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'åŒæ­¥æ•°æ®å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }

  // è‡ªåŠ¨æ•°æ®åŒæ­¥ï¼šå¦‚æœenhancedConductorsä¸ºç©ºä½†mainStoreæœ‰æ•°æ®ï¼Œè‡ªåŠ¨åŒæ­¥
  const autoSyncIfNeeded = async () => {
    const hasEnhancedData = Object.keys(enhancedConductors.value).length > 0
    const hasBasicData = mainStore.conductors.length > 0
    
    if (!hasEnhancedData && hasBasicData) {
      console.log('ğŸ”„ æ£€æµ‹åˆ°æ•°æ®ä¸ä¸€è‡´ï¼Œè‡ªåŠ¨åŒæ­¥ä¸­...')
      await syncWithMainStore()
      console.log('âœ… æ•°æ®åŒæ­¥å®Œæˆ')
    }
  }

  const saveToDatabase = async () => {
    if (!mainStore.database) return false

    // æ›´æ–°æ•°æ®åº“
    mainStore.database.enhancedConductors = enhancedConductors.value
    mainStore.database.personnelChanges = personnelChanges.value
    mainStore.database.applicationSettings = applicationSettings.value

    return await mainStore.saveDatabase()
  }

  const loadFromDatabase = async () => {
    if (!mainStore.database) return

    // åŠ è½½å¢å¼ºçš„äººå‘˜æ•°æ®
    if (mainStore.database.enhancedConductors) {
      enhancedConductors.value = mainStore.database.enhancedConductors
    }

    // åŠ è½½å¼‚åŠ¨è®°å½•
    if (mainStore.database.personnelChanges) {
      personnelChanges.value = mainStore.database.personnelChanges
    }

    // åŠ è½½ç”³è¯·é…ç½®
    if (mainStore.database.applicationSettings) {
      applicationSettings.value = mainStore.database.applicationSettings
    }

    // è‡ªåŠ¨åŒæ­¥æ•°æ®ï¼ˆå¦‚æœéœ€è¦ï¼‰
    await autoSyncIfNeeded()
  }

  // å·¥å…·å‡½æ•°
  const generateId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2)
  }

  const getConductorByEmployeeId = (employeeId: string) => {
    return allConductors.value.find(c => c.employeeId === employeeId)
  }

      return {
    // çŠ¶æ€
    enhancedConductors,
    personnelChanges,
    applicationSettings,
    loading,
    error,

    // è®¡ç®—å±æ€§
    allConductors,
    getConductorsByStatus,
    getConductorsByDepartment,
    statusStatistics,
    departmentStatistics,

    // æ“ä½œæ–¹æ³•
    addConductor,
    updateConductor,
    deleteConductor,
    addPersonnelChange,
    createApplicationRelatedChange,
    getPersonnelChangesByEmployee,
    getPersonnelChanges,
    getPersonnelChangeStatistics,
    deletePersonnelChange,
    updatePersonnelChange,
    syncWithMainStore,
    autoSyncIfNeeded,
    saveToDatabase,
    loadFromDatabase,
    getConductorByEmployeeId
  }
}) 